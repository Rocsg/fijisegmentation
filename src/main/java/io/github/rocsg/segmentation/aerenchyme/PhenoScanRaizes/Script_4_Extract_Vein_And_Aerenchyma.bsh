/**
 * Script_4_Extract_Vein_And_Aerenchyma.bsh
 * 
 * Applies morphological operations to extract vein and aerenchyma
 * Similar to E_Extract_areas operations
 * Input:  BASE_DIR/Processing/3_Predicted_segmentation/*.tif
 * Output: BASE_DIR/Processing/4_Segmentation/*_vein.tif, *_aerenchyma.tif
 */

import ij.*;
import ij.io.*;
import ij.process.*;
import ij.plugin.*;
import ij.plugin.filter.*;
import java.io.*;
import java.util.*;
import inra.ijpb.binary.geodesic.GeodesicDistanceTransformFloat;
import inra.ijpb.morphology.Morphology;
import inra.ijpb.morphology.Strel3D;


   



// Morphological parameters
int FILL_RADIUS = 3;
int OPENING_RADIUS = 16;
String BASE_DIR="";
// Ask user for main directory

boolean test=false;
if(!test){
	DirectoryChooser dc = new DirectoryChooser("Select main project directory");
	BASE_DIR = dc.getDirectory();
}
else{
	BASE_DIR="/home/rfernandez/Bureau/A_Test/Aerenchyme/Test_CIAT/";
}
if (BASE_DIR == null) {
    IJ.error("No directory selected");
    return;
}

String IN_DIR = BASE_DIR + "Processing" + File.separator + "3_Predicted_segmentation" + File.separator;
String OUT_VEIN_DIR = BASE_DIR + "Processing" + File.separator + "4_Segmentation_Vein" + File.separator;
String OUT_AERENCHYMA_DIR = BASE_DIR + "Processing" + File.separator + "4_Segmentation_Aerenchyma" + File.separator;

// Debug output directories
String DEBUG_FILLED_DIR = BASE_DIR + "Processing" + File.separator + "4_Debug_1_Holes_Filled" + File.separator;
String DEBUG_CENTRAL_DIR = BASE_DIR + "Processing" + File.separator + "4_Debug_2_Central_Component" + File.separator;
String DEBUG_ERODED_DIR = BASE_DIR + "Processing" + File.separator + "4_Debug_3_Eroded" + File.separator;
String DEBUG_OPENED_DIR = BASE_DIR + "Processing" + File.separator + "4_Debug_4_Opened" + File.separator;

// Check directory
File inFolder = new File(IN_DIR);
if (!inFolder.exists()) {
    IJ.error("Input directory not found: " + IN_DIR);
    return;
}

// Create output directories
new File(OUT_VEIN_DIR).mkdirs();
new File(OUT_AERENCHYMA_DIR).mkdirs();
new File(DEBUG_FILLED_DIR).mkdirs();
new File(DEBUG_CENTRAL_DIR).mkdirs();
new File(DEBUG_ERODED_DIR).mkdirs();
new File(DEBUG_OPENED_DIR).mkdirs();

IJ.log("\\Clear");
IJ.log("=== Script 4: Extract Vein and Aerenchyma ===");
IJ.log("Input:  " + IN_DIR);
IJ.log("Output Vein: " + OUT_VEIN_DIR);
IJ.log("Output Aerenchyma: " + OUT_AERENCHYMA_DIR);

// Get all tif files
File[] files = inFolder.listFiles(new FilenameFilter() {
    public boolean accept(File dir, String name) {
        return name.toLowerCase().endsWith(".tif") || name.toLowerCase().endsWith(".tiff");
    }
});

if (files == null || files.length == 0) {
    IJ.error("No segmentation files found");
    return;
}

int count = 0;
boolean test=false;
for (File file : files) {
    String filename = file.getName();
    String baseName = filename.substring(0, filename.lastIndexOf('.'));
    
    IJ.log("\nProcessing: " + filename);
    
    // Open segmentation
    ImagePlus imp = IJ.openImage(file.getAbsolutePath());
    if (imp == null) {
        IJ.log("  ERROR: Could not open " + filename);
        continue;
    }
	double pixSizeX=imp.getCalibration().pixelWidth;
	
	Strel3D str2 = inra.ijpb.morphology.strel.DiskStrel.fromRadius(OPENING_RADIUS);
    
    // Step 1: Fill holes
    IJ.log("  Step 1: Filling holes...");
    ImagePlus filled = imp.duplicate();
    IJ.run(filled, "Invert", "");
    IJ.run(filled, "Fill Holes", "");
    IJ.run(filled, "Invert", "");
    
    // Save debug: filled
    String debugFilledPath = DEBUG_FILLED_DIR + baseName + "_filled.tif";
    new FileSaver(filled).saveAsTiff(debugFilledPath);
    
    // Step 2: Keep largest connected component (central CC)
    IJ.log("  Step 2: Extracting largest component...");
    ByteProcessor bp = (ByteProcessor) filled.getProcessor();
    int w = bp.getWidth(), h = bp.getHeight();
    
    // Label connected components
    int[][] labels = new int[h][w];
    List counts = new ArrayList();
    counts.add(0);
    List sumX = new ArrayList();
    sumX.add(0.0);
    List sumY = new ArrayList();
    sumY.add(0.0);
    
    int lbl = 0;
    Stack stack = new Stack();
    
    for (int y = 0; y < h; y++) {
        for (int x = 0; x < w; x++) {
            if (bp.get(x, y) == 255 && labels[y][x] == 0) {
                lbl++;
                counts.add(0);
                sumX.add(0.0);
                sumY.add(0.0);
                stack.clear();
                stack.push(new int[]{x, y});
                labels[y][x] = lbl;
                
                while (!stack.isEmpty()) {
                    int[] p = (int[]) stack.pop();
                    int px = p[0], py = p[1];
                    sumX.set(lbl, (Double)sumX.get(lbl) + px);
                    sumY.set(lbl, (Double)sumY.get(lbl) + py);
                    counts.set(lbl, (Integer)counts.get(lbl) + 1);
                    
                    int[][] dirs = {{1,0}, {-1,0}, {0,1}, {0,-1}};
                    for (int d = 0; d < dirs.length; d++) {
                        int nx = px + dirs[d][0];
                        int ny = py + dirs[d][1];
                        if (nx >= 0 && nx < w && ny >= 0 && ny < h &&
                            bp.get(nx, ny) == 255 && labels[ny][nx] == 0) {
                            labels[ny][nx] = lbl;
                            stack.push(new int[]{nx, ny});
                        }
                    }
                }
            }
        }
    }
    
    // Find component closest to center
    double cx0 = w / 2.0, cy0 = h / 2.0;
    double bestDist = Double.MAX_VALUE;
    int bestLabel = 0;
    
    for (int L = 1; L <= lbl; L++) {
        int cnt = (Integer) counts.get(L);
        if (cnt == 0) continue;
        double cx = (Double)sumX.get(L) / cnt;
        double cy = (Double)sumY.get(L) / cnt;
        double d2 = (cx - cx0) * (cx - cx0) + (cy - cy0) * (cy - cy0);
        if (d2 < bestDist) {
            bestDist = d2;
            bestLabel = L;
        }
    }
    
    // Create mask with only central component
    ByteProcessor centralBp = new ByteProcessor(w, h);
    for (int y = 0; y < h; y++) {
        for (int x = 0; x < w; x++) {
            if (labels[y][x] == bestLabel) {
                centralBp.set(x, y, 255);
            }
        }
    }
    ImagePlus central = new ImagePlus("central", centralBp);
    
    // Save debug: central component
    String debugCentralPath = DEBUG_CENTRAL_DIR + baseName + "_central.tif";
    new FileSaver(central).saveAsTiff(debugCentralPath);
    
    
    // Step 3: Morphological opening (erosion then dilation)
    IJ.log("  Step 3: Applying morphological opening...");
    ImagePlus eroded = central.duplicate();
    eroded= new ImagePlus("", Morphology.erosion(eroded.getImageStack(), str2));
    
    
    // Save debug: eroded
    String debugErodedPath = DEBUG_ERODED_DIR + baseName + "_eroded.tif";
    new FileSaver(eroded).saveAsTiff(debugErodedPath);
    
    ImagePlus opened = eroded.duplicate();
 	opened= new ImagePlus("", Morphology.dilation(opened.getImageStack(), str2));
   
    
    // Save debug: opened
    String debugOpenedPath = DEBUG_OPENED_DIR + baseName + "_opened.tif";
    new FileSaver(opened).saveAsTiff(debugOpenedPath);
    
    // Keep only largest connected component after opening
    IJ.log("  Step 3b: Extracting largest component from opened result...");
    ByteProcessor openedBp = (ByteProcessor) opened.getProcessor();
    int[][] labelsOpened = new int[h][w];
    List countsOpened = new ArrayList();
    countsOpened.add(0);
    
    int lblOpened = 0;
    Stack stackOpened = new Stack();
    
    for (int y = 0; y < h; y++) {
        for (int x = 0; x < w; x++) {
            if (openedBp.get(x, y) == 255 && labelsOpened[y][x] == 0) {
                lblOpened++;
                countsOpened.add(0);
                stackOpened.clear();
                stackOpened.push(new int[]{x, y});
                labelsOpened[y][x] = lblOpened;
                
                while (!stackOpened.isEmpty()) {
                    int[] p = (int[]) stackOpened.pop();
                    int px = p[0], py = p[1];
                    countsOpened.set(lblOpened, (Integer)countsOpened.get(lblOpened) + 1);
                    
                    int[][] dirs = {{1,0}, {-1,0}, {0,1}, {0,-1}};
                    for (int d = 0; d < dirs.length; d++) {
                        int nx = px + dirs[d][0];
                        int ny = py + dirs[d][1];
                        if (nx >= 0 && nx < w && ny >= 0 && ny < h &&
                            openedBp.get(nx, ny) == 255 && labelsOpened[ny][nx] == 0) {
                            labelsOpened[ny][nx] = lblOpened;
                            stackOpened.push(new int[]{nx, ny});
                        }
                    }
                }
            }
        }
    }
    
    // Find largest component
    int maxCount = 0;
    int largestLabel = 0;
    for (int L = 1; L <= lblOpened; L++) {
        int cnt = (Integer) countsOpened.get(L);
        if (cnt > maxCount) {
            maxCount = cnt;
            largestLabel = L;
        }
    }
    
    // Keep only largest component
    ByteProcessor largestBp = new ByteProcessor(w, h);
    for (int y = 0; y < h; y++) {
        for (int x = 0; x < w; x++) {
            if (labelsOpened[y][x] == largestLabel) {
                largestBp.set(x, y, 255);
            }
        }
    }
    opened = new ImagePlus("opened_largest", largestBp);
    
    // Step 4: Extract vein and aerenchyma
    IJ.log("  Step 4: Extracting vein and aerenchyma...");
    
    // Vein = the opened result (what was previously called "aerenchyma")
    String veinPath = OUT_VEIN_DIR + baseName + "_vein.tif";
    FileSaver fsVein = new FileSaver(opened);
    fsVein.saveAsTiff(veinPath);
    IJ.log("  Saved: " + baseName + "_vein.tif");
    
    // Aerenchyma = pixels that are 255 in vein AND 0 in original predicted segmentation
    openedBp = (ByteProcessor) opened.getProcessor();
    ByteProcessor originalBp = (ByteProcessor) imp.getProcessor();
    ByteProcessor aerenchymaBp = new ByteProcessor(w, h);
    
    for (int y = 0; y < h; y++) {
        for (int x = 0; x < w; x++) {
            if (openedBp.get(x, y) == 255 && originalBp.get(x, y) == 0) {
                aerenchymaBp.set(x, y, 255);
            }
        }
    }
    
    ImagePlus aerenchyma = new ImagePlus(baseName + "_aerenchyma", aerenchymaBp);
    String aerenchymaPath = OUT_AERENCHYMA_DIR + baseName + "_aerenchyma.tif";
    FileSaver fsAer = new FileSaver(aerenchyma);
    fsAer.saveAsTiff(aerenchymaPath);
    IJ.log("  Saved: " + baseName + "_aerenchyma.tif");
    
    // Cleanup
    imp.close();
    filled.close();
    central.close();
    eroded.close();
    opened.close();
    aerenchyma.close();
    
    count++;
	if(test)break;
}

IJ.log("\n=== Completed: " + count + " patches processed ===");
IJ.showMessage("Script 4 Complete", count + " patches processed");
